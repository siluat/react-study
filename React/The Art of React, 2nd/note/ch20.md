# 20장 서버 사이드 렌더링

### 서버 사이드 렌더링과 코드 스플리팅 충돌

- SSR과 코드 스플리팅을 별도의 호환 작업없이 함께 적용하면 페이지 깜박임 등의 문제가 발생한다.
- 라우트 경로마다 코드 스플리팅된 파일 중에서 필요한 모든 파일을 브라우저에서 렌더링하기 전에 미리 불러와야 한다.
- Loadable Components 라이브러리의 기능을 써서 해결할 수도 있다.

### 서버 사이드 렌더링 준비

- 웹팩 설정을 커스터마이징해야 하므로 CRA로 만든 프로젝트라면 eject를 해야 한다.
- 기존 엔트리인 index.js 와 별도로 서버를 위한 엔트리 파일 작성한다.
- 서버 사이드 렌더링 전용 웹팩 설정 작성한다.
  - SSR용 별도 엔트리 파일을 번들링하기 위한 로더 설정
  - 서버에서는 직접 node_modules로 접근할 수 있기 때문에, node_modules에 있는 라이브러리들은 제외하고 번들링하는 것이 좋다. (webpack-node-externals 사용)
- 빌드 스크립트 작성한다.
  - SSR용 웹팩 설정을 이용해서 빌드를 하는 스크립트를 작성한다.
- 서버 코드 작성
  - SSR용 엔트리 파일에 서버 코드를 작성한다. Express, Koa, Hapi 등의 프레임워크/라이브러리를 사용할 수 있다.
- 정적 파일의 제공
  - 리액트 컴포넌트의 직접적인 처리와 관련이 없는 JS 파일이나 CSS 파일은 서버를 통해 정적 리소스로 접근할 수 있게 처리하면 좋다.
  - 이때 정적 파일들은 기존 CSR 용 빌드 결과를 이용하여 SSR 용 파일에 끌어다 사용할 수 있다. (CSR 빌드의 asset-manifest.json 파일 활용)

### 데이터 로딩

- SSR에서는 리액트 state나 리덕스 스토어 등의 상태가 바뀌면 자동으로 리렌더링되거나 하지 않는다. 또한 componentDidMount 같은 라이프사이클 API도 사용할 수 없다. 해결 방안은 다양하다.
- **PreloadContext 사용 :** SSR 과정에서 처리해야 할 작업들을 Promise로 처리하고, 모든 프로미스가 끝난 뒤 데이터가 채워진 상태로 다시 렌더링을 한다.

### SSR과 코드 스플리팅

- 공식 코드 스플리팅 기능인 React.lazy와 Suspense는 SSR를 지원하지 않고 있다. Loadable Components 사용이 권장된다.
- Loadable Components는 SSR을 위한 서버 유틸 함수, 웹팩 플러그인 babel 플러그인을 제공하고 있다.
  - @loadable/server
  - @loadable/webpack-plugin
  - @loadable/babel-plugin

### SSR 환경 구축 대안

SSR을 직접 구현하기보다 SSR 지원이 되는 프레임워크나 도구를 사용하는 것도 방법이다. 상황에 따라 판단하여 사용한다.

- Next.js
- Razzle
